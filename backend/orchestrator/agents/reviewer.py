"""
Reviewer agent implementation.

The ReviewerAgent is responsible for reviewing and validating code patches
generated by the DeveloperAgent. It performs multi-level validation including
syntax checking, code conventions, test coverage requirements, and basic security
analysis. The agent provides structured feedback and quality scores to guide
the iterative development cycle.

It supports different validation criteria based on the technology stack and
provides actionable recommendations for improvement.
"""

from __future__ import annotations

from dataclasses import dataclass, field
from typing import Any, List, Optional, Dict, Union
from enum import Enum
import logging
import re
import ast
import json

from ..plan_parser import Step


class ValidationLevel(Enum):
    """Enumeration of validation severity levels."""
    CRITICAL = "critical"
    WARNING = "warning" 
    INFO = "info"
    SUGGESTION = "suggestion"


class ValidationCategory(Enum):
    """Categories of validation checks."""
    SYNTAX = "syntax"
    CONVENTIONS = "conventions"
    SECURITY = "security"
    TESTS = "tests"
    STRUCTURE = "structure"
    PERFORMANCE = "performance"


@dataclass
class ValidationIssue:
    """Represents a single validation issue found in a patch."""
    category: ValidationCategory
    level: ValidationLevel
    message: str
    file_path: Optional[str] = None
    line_number: Optional[int] = None
    code_snippet: Optional[str] = None
    suggestion: Optional[str] = None


@dataclass
class ReviewFeedback:
    """Comprehensive feedback from patch review."""
    overall_score: float  # 0.0 to 100.0
    should_accept: bool
    issues: List[ValidationIssue] = field(default_factory=list)
    recommendations: List[str] = field(default_factory=list)
    stack_specific_notes: Dict[str, Any] = field(default_factory=dict)
    
    def critical_issues_count(self) -> int:
        """Count critical issues."""
        return sum(1 for issue in self.issues if issue.level == ValidationLevel.CRITICAL)
    
    def warning_issues_count(self) -> int:
        """Count warning issues."""
        return sum(1 for issue in self.issues if issue.level == ValidationLevel.WARNING)


class ReviewerAgent:
    """
    Multi-level code patch reviewer with stack-specific validation.
    
    The ReviewerAgent validates patches across multiple dimensions:
    - Syntax and code structure validation
    - Adherence to coding conventions and style guides
    - Test coverage and quality requirements
    - Basic security vulnerability detection
    - Performance considerations
    
    Parameters
    ----------
    llm_router: Any
        LLM router for intelligent analysis when needed
    max_issues_per_category: int
        Maximum issues to report per category to avoid noise
    minimum_score_threshold: float
        Minimum score (0-100) required for patch acceptance
    logger: logging.Logger | None
        Optional logger for debugging
    """

    def __init__(
        self,
        llm_router: Any = None,
        max_issues_per_category: int = 10,
        minimum_score_threshold: float = 70.0,
        logger: Optional[logging.Logger] = None,
    ) -> None:
        self.llm_router = llm_router
        self.max_issues_per_category = max_issues_per_category
        self.minimum_score_threshold = minimum_score_threshold
        self.log = logger or logging.getLogger(__name__)

    async def review_patch(
        self,
        patch: str,
        step: Step,
        test_results: Optional[List[Dict[str, Any]]] = None,
        stack: Optional[str] = None,
        project_path: Optional[str] = None
    ) -> ReviewFeedback:
        """
        Perform comprehensive review of a code patch.
        
        Args:
            patch: The unified diff patch to review
            step: The step this patch implements
            test_results: Optional test results to inform the review
            stack: Technology stack (e.g., 'laravel', 'react', 'python')
            project_path: Path to the project for context
            
        Returns:
            ReviewFeedback with validation results and recommendations
        """
        self.log.info(f"Starting review for step {step.id}: {step.description[:50]}...")
        
        feedback = ReviewFeedback(
            overall_score=100.0,
            should_accept=True,
            issues=[],
            recommendations=[]
        )
        
        # Parse patch to extract file changes
        file_changes = self._parse_patch_files(patch)
        
        # Stack-specific validation
        stack = (stack or "generic").lower()
        self.log.debug(f"Using stack-specific validation for: {stack}")
        
        # Core validation phases
        await self._validate_syntax(feedback, file_changes, stack)
        await self._validate_conventions(feedback, file_changes, stack)
        await self._validate_security(feedback, file_changes, stack)
        await self._validate_tests(feedback, file_changes, step, test_results, stack)
        await self._validate_structure(feedback, file_changes, stack)
        
        # Calculate final score and acceptance decision
        self._calculate_final_score(feedback)
        feedback.should_accept = self._should_accept_patch(feedback)
        
        # Generate recommendations
        self._generate_recommendations(feedback, step, stack)
        
        self.log.info(f"Review completed. Score: {feedback.overall_score:.1f}, Accept: {feedback.should_accept}")
        return feedback

    def should_accept_patch(self, feedback: ReviewFeedback) -> tuple[bool, str]:
        """
        Determine if patch should be accepted based on review feedback.
        
        Returns:
            Tuple of (should_accept: bool, reason: str)
        """
        if feedback.critical_issues_count() > 0:
            critical_issues = [issue.message for issue in feedback.issues 
                             if issue.level == ValidationLevel.CRITICAL]
            return False, f"Critical issues found: {'; '.join(critical_issues[:3])}"
        
        if feedback.overall_score < self.minimum_score_threshold:
            return False, f"Quality score {feedback.overall_score:.1f} below threshold {self.minimum_score_threshold}"
        
        if feedback.warning_issues_count() > 5:
            return False, f"Too many warnings ({feedback.warning_issues_count()}), needs refinement"
        
        return True, f"Patch meets quality standards (score: {feedback.overall_score:.1f})"

    # ========== Patch parsing ==========
    
    def _parse_patch_files(self, patch: str) -> Dict[str, Dict[str, Any]]:
        """
        Parse patch to extract file-level changes.
        
        Returns:
            Dict mapping file paths to change information
        """
        files = {}
        current_file = None
        current_content = []
        
        for line in patch.split('\
'):
            # New file header
            if line.startswith('diff --git'):
                if current_file:
                    files[current_file]['content'] = '\
'.join(current_content)
                
                # Extract file path from "diff --git a/path b/path"
                parts = line.split()
                if len(parts) >= 4:
                    current_file = parts[3][2:]  # Remove "b/" prefix
                    files[current_file] = {
                        'additions': 0,
                        'deletions': 0,
                        'content': '',
                        'is_new_file': False,
                        'is_deleted': False
                    }
                    current_content = []
            
            # File metadata
            elif current_file and line.startswith('new file'):
                files[current_file]['is_new_file'] = True
            elif current_file and line.startswith('deleted file'):
                files[current_file]['is_deleted'] = True
            
            # Count additions/deletions
            elif current_file and line.startswith('+') and not line.startswith('+++'):
                files[current_file]['additions'] += 1
                current_content.append(line)
            elif current_file and line.startswith('-') and not line.startswith('---'):
                files[current_file]['deletions'] += 1
                current_content.append(line)
            elif current_file:
                current_content.append(line)
        
        # Handle last file
        if current_file:
            files[current_file]['content'] = '\
'.join(current_content)
        
        return files

    # ========== Validation methods ==========
    
    async def _validate_syntax(self, feedback: ReviewFeedback, file_changes: Dict[str, Any], stack: str) -> None:
        """Validate syntax and basic code structure."""
        issues_count = 0
        
        for file_path, changes in file_changes.items():
            if issues_count >= self.max_issues_per_category:
                break
                
            # Extract added lines for syntax checking
            added_lines = []
            for line in changes['content'].split('\
'):
                if line.startswith('+') and not line.startswith('+++'):
                    added_lines.append(line[1:])  # Remove + prefix
            
            if not added_lines:
                continue
                
            # Stack-specific syntax validation
            if stack == 'python' and file_path.endswith('.py'):
                issues_count += await self._validate_python_syntax(feedback, file_path, added_lines)
            elif stack == 'laravel' and file_path.endswith('.php'):
                issues_count += await self._validate_php_syntax(feedback, file_path, added_lines)
            elif stack in ['react', 'vue', 'node'] and file_path.endswith(('.js', '.ts', '.jsx', '.tsx')):
                issues_count += await self._validate_javascript_syntax(feedback, file_path, added_lines)

    async def _validate_python_syntax(self, feedback: ReviewFeedback, file_path: str, lines: List[str]) -> int:
        """Validate Python-specific syntax."""
        issues_added = 0
        code = '\
'.join(lines)
        
        try:
            # Try to parse as AST
            ast.parse(code)
        except SyntaxError as e:
            feedback.issues.append(ValidationIssue(
                category=ValidationCategory.SYNTAX,
                level=ValidationLevel.CRITICAL,
                message=f"Python syntax error: {e.msg}",
                file_path=file_path,
                line_number=e.lineno,
                suggestion="Fix syntax error before applying patch"
            ))
            issues_added += 1
        
        # Check for common Python issues
        for i, line in enumerate(lines, 1):
            line_stripped = line.strip()
            
            # Check for missing imports
            if 'import ' in line and line.count('import') > 3:
                feedback.issues.append(ValidationIssue(
                    category=ValidationCategory.CONVENTIONS,
                    level=ValidationLevel.WARNING,
                    message="Consider splitting multiple imports into separate lines",
                    file_path=file_path,
                    line_number=i,
                    suggestion="Use separate import lines for better readability"
                ))
                issues_added += 1
            
            # Check for long lines
            if len(line) > 120:
                feedback.issues.append(ValidationIssue(
                    category=ValidationCategory.CONVENTIONS,
                    level=ValidationLevel.INFO,
                    message=f"Line too long ({len(line)} chars, recommended max 120)",
                    file_path=file_path,
                    line_number=i,
                    suggestion="Break long lines for better readability"
                ))
                issues_added += 1
        
        return issues_added

    async def _validate_php_syntax(self, feedback: ReviewFeedback, file_path: str, lines: List[str]) -> int:
        """Validate PHP-specific syntax."""
        issues_added = 0
        
        for i, line in enumerate(lines, 1):
            line_stripped = line.strip()
            
            # Check for missing semicolons
            if (line_stripped and not line_stripped.endswith((';', '{', '}', ':', '?>', '*/', '//'))) and \\
               not line_stripped.startswith(('*', '//', '/*', '#', 'if', 'else', 'while', 'for', 'foreach', 'class', 'function')):
                if re.search(r'[a-zA-Z0-9_\\)\\]]\\s*$', line_stripped):
                    feedback.issues.append(ValidationIssue(
                        category=ValidationCategory.SYNTAX,
                        level=ValidationLevel.WARNING,
                        message="Possible missing semicolon",
                        file_path=file_path,
                        line_number=i,
                        suggestion="Add semicolon at end of statement"
                    ))
                    issues_added += 1
            
            # Check Laravel-specific patterns
            if '$this->' in line and not re.search(r'->\\w+\\(', line):
                feedback.issues.append(ValidationIssue(
                    category=ValidationCategory.CONVENTIONS,
                    level=ValidationLevel.INFO,
                    message="Consider using method calls instead of direct property access",
                    file_path=file_path,
                    line_number=i,
                    suggestion="Use getter methods for better encapsulation"
                ))
                issues_added += 1
        
        return issues_added

    async def _validate_javascript_syntax(self, feedback: ReviewFeedback, file_path: str, lines: List[str]) -> int:
        """Validate JavaScript/TypeScript syntax."""
        issues_added = 0
        
        for i, line in enumerate(lines, 1):
            line_stripped = line.strip()
            
            # Check for var usage (prefer let/const)
            if 'var ' in line and not line_stripped.startswith('//'):
                feedback.issues.append(ValidationIssue(
                    category=ValidationCategory.CONVENTIONS,
                    level=ValidationLevel.WARNING,
                    message="Consider using 'let' or 'const' instead of 'var'",
                    file_path=file_path,
                    line_number=i,
                    suggestion="Use 'const' for immutable values, 'let' for mutable ones"
                ))
                issues_added += 1
            
            # Check for console.log in production code
            if 'console.log' in line and not file_path.endswith(('.test.js', '.spec.js')):
                feedback.issues.append(ValidationIssue(
                    category=ValidationCategory.CONVENTIONS,
                    level=ValidationLevel.INFO,
                    message="Remove console.log statements from production code",
                    file_path=file_path,
                    line_number=i,
                    suggestion="Use proper logging mechanism or remove debug statements"
                ))
                issues_added += 1
        
        return issues_added

    async def _validate_conventions(self, feedback: ReviewFeedback, file_changes: Dict[str, Any], stack: str) -> None:
        """Validate coding conventions and style guidelines."""
        for file_path, changes in file_changes.items():
            # Check file naming conventions
            if not self._check_file_naming_conventions(file_path, stack):
                feedback.issues.append(ValidationIssue(
                    category=ValidationCategory.CONVENTIONS,
                    level=ValidationLevel.WARNING,
                    message=f"File name doesn't follow {stack} conventions",
                    file_path=file_path,
                    suggestion=self._get_naming_suggestion(file_path, stack)
                ))

    def _check_file_naming_conventions(self, file_path: str, stack: str) -> bool:
        """Check if file follows naming conventions for the stack."""
        filename = file_path.split('/')[-1]
        
        if stack == 'laravel':
            # Laravel conventions: PascalCase for classes, snake_case for others
            if filename.endswith('.php'):
                # Controllers, Models should be PascalCase
                if any(term in file_path.lower() for term in ['controller', 'model']):
                    return re.match(r'^[A-Z][a-zA-Z0-9]*\\.php$', filename)
                # Migrations, config files should be snake_case
                return True  # More lenient for other PHP files
        
        elif stack == 'react':
            # React: PascalCase for components, camelCase for utilities
            if filename.endswith(('.jsx', '.tsx')):
                return re.match(r'^[A-Z][a-zA-Z0-9]*\\.(jsx|tsx)$', filename)
            return True
        
        elif stack == 'python':
            # Python: snake_case for everything
            if filename.endswith('.py'):
                return re.match(r'^[a-z][a-z0-9_]*\\.py$', filename) or filename == '__init__.py'
        
        return True

    def _get_naming_suggestion(self, file_path: str, stack: str) -> str:
        """Get naming suggestion for the file."""
        filename = file_path.split('/')[-1]
        
        if stack == 'laravel' and filename.endswith('.php'):
            return "Use PascalCase for Controllers and Models (e.g., UserController.php)"
        elif stack == 'react' and filename.endswith(('.jsx', '.tsx')):
            return "Use PascalCase for React components (e.g., UserProfile.jsx)"
        elif stack == 'python' and filename.endswith('.py'):
            return "Use snake_case for Python files (e.g., user_service.py)"
        
        return "Follow standard naming conventions for your technology stack"

    async def _validate_security(self, feedback: ReviewFeedback, file_changes: Dict[str, Any], stack: str) -> None:
        """Perform basic security validation."""
        for file_path, changes in file_changes.items():
            content = changes['content']
            
            # Check for common security issues
            security_patterns = [
                (r'password\\s*=\\s*["\\'][^"\\']*["\\']', "Hardcoded password detected"),
                (r'api[_-]?key\\s*=\\s*["\\'][^"\\']*["\\']', "Hardcoded API key detected"), 
                (r'secret\\s*=\\s*["\\'][^"\\']*["\\']', "Hardcoded secret detected"),
                (r'eval\\s*\\(', "Use of eval() function is dangerous"),
                (r'exec\\s*\\(', "Use of exec() function can be dangerous"),
                (r'system\\s*\\(', "Direct system calls should be avoided"),
                (r'SELECT\\s+\\*\\s+FROM.*\\$', "Possible SQL injection vulnerability"),
            ]
            
            for pattern, message in security_patterns:
                if re.search(pattern, content, re.IGNORECASE):
                    feedback.issues.append(ValidationIssue(
                        category=ValidationCategory.SECURITY,
                        level=ValidationLevel.CRITICAL,
                        message=message,
                        file_path=file_path,
                        suggestion="Use environment variables or secure configuration methods"
                    ))

    async def _validate_tests(
        self, 
        feedback: ReviewFeedback, 
        file_changes: Dict[str, Any], 
        step: Step,
        test_results: Optional[List[Dict[str, Any]]],
        stack: str
    ) -> None:
        """Validate test coverage and quality."""
        has_test_files = any(
            self._is_test_file(file_path, stack) 
            for file_path in file_changes.keys()
        )
        
        has_logic_changes = any(
            not self._is_test_file(file_path, stack) and changes['additions'] > 0
            for file_path, changes in file_changes.items()
        )
        
        # If logic changes without test changes, flag it
        if has_logic_changes and not has_test_files:
            feedback.issues.append(ValidationIssue(
                category=ValidationCategory.TESTS,
                level=ValidationLevel.WARNING,
                message="Code changes without corresponding test updates",
                suggestion="Add or update tests to cover new functionality"
            ))
        
        # Analyze test results if provided
        if test_results:
            failed_tests = [result for result in test_results if result.get('status') == 'failed']
            if failed_tests:
                for failed_test in failed_tests[:3]:  # Limit to first 3
                    feedback.issues.append(ValidationIssue(
                        category=ValidationCategory.TESTS,
                        level=ValidationLevel.CRITICAL,
                        message=f"Test failure: {failed_test.get('name', 'Unknown test')}",
                        suggestion="Fix failing tests before applying patch"
                    ))

    def _is_test_file(self, file_path: str, stack: str) -> bool:
        """Check if file is a test file based on stack conventions."""
        filename = file_path.lower()
        
        if stack == 'laravel':
            return '/tests/' in filename or filename.endswith('test.php')
        elif stack in ['react', 'vue', 'node']:
            return (filename.endswith(('.test.js', '.test.ts', '.spec.js', '.spec.ts')) or
                   '/tests/' in filename or '/__tests__/' in filename)
        elif stack == 'python':
            return (filename.startswith('test_') or filename.endswith('_test.py') or
                   '/tests/' in filename)
        
        return False

    async def _validate_structure(self, feedback: ReviewFeedback, file_changes: Dict[str, Any], stack: str) -> None:
        """Validate code structure and architecture patterns."""
        for file_path, changes in file_changes.items():
            # Check for excessively large files
            if changes['additions'] > 200:
                feedback.issues.append(ValidationIssue(
                    category=ValidationCategory.STRUCTURE,
                    level=ValidationLevel.WARNING,
                    message=f"Large number of additions ({changes['additions']} lines)",
                    file_path=file_path,
                    suggestion="Consider breaking changes into smaller, focused commits"
                ))
            
            # Stack-specific structure validation
            if stack == 'laravel' and 'Controller.php' in file_path:
                self._validate_laravel_controller_structure(feedback, file_path, changes)
            elif stack == 'react' and file_path.endswith(('.jsx', '.tsx')):
                self._validate_react_component_structure(feedback, file_path, changes)

    def _validate_laravel_controller_structure(self, feedback: ReviewFeedback, file_path: str, changes: Dict[str, Any]) -> None:
        """Validate Laravel controller structure."""
        content = changes['content']
        
        # Check for proper controller structure
        if 'class ' in content and 'Controller' in content:
            if 'public function' not in content:
                feedback.issues.append(ValidationIssue(
                    category=ValidationCategory.STRUCTURE,
                    level=ValidationLevel.INFO,
                    message="Controller class without public methods",
                    file_path=file_path,
                    suggestion="Controllers should have public action methods"
                ))

    def _validate_react_component_structure(self, feedback: ReviewFeedback, file_path: str, changes: Dict[str, Any]) -> None:
        """Validate React component structure."""
        content = changes['content']
        
        # Check for proper component export
        if 'function ' in content or 'const ' in content:
            if 'export default' not in content and 'export {' not in content:
                feedback.issues.append(ValidationIssue(
                    category=ValidationCategory.STRUCTURE,
                    level=ValidationLevel.WARNING,
                    message="Component without proper export",
                    file_path=file_path,
                    suggestion="Add 'export default' or named export for component"
                ))

    # ========== Scoring and decision logic ==========
    
    def _calculate_final_score(self, feedback: ReviewFeedback) -> None:
        """Calculate overall quality score based on issues found."""
        score = 100.0
        
        # Deduct points for each issue type
        for issue in feedback.issues:
            if issue.level == ValidationLevel.CRITICAL:
                score -= 25.0
            elif issue.level == ValidationLevel.WARNING:
                score -= 10.0
            elif issue.level == ValidationLevel.INFO:
                score -= 3.0
            elif issue.level == ValidationLevel.SUGGESTION:
                score -= 1.0
        
        # Ensure score doesn't go below 0
        feedback.overall_score = max(0.0, score)

    def _should_accept_patch(self, feedback: ReviewFeedback) -> bool:
        """Determine if patch should be accepted based on feedback."""
        # Reject if critical issues exist
        if feedback.critical_issues_count() > 0:
            return False
        
        # Reject if score is too low
        if feedback.overall_score < self.minimum_score_threshold:
            return False
        
        # Reject if too many warnings (indicates poor quality)
        if feedback.warning_issues_count() > 5:
            return False
        
        return True

    def _generate_recommendations(self, feedback: ReviewFeedback, step: Step, stack: str) -> None:
        """Generate actionable recommendations based on review results."""
        if feedback.critical_issues_count() > 0:
            feedback.recommendations.append(
                "Address all critical issues before resubmitting the patch"
            )
        
        if feedback.warning_issues_count() > 2:
            feedback.recommendations.append(
                "Review and fix warning-level issues to improve code quality"
            )
        
        # Stack-specific recommendations
        stack_recommendations = self._get_stack_specific_recommendations(stack, feedback.issues)
        feedback.recommendations.extend(stack_recommendations)
        
        # Generic recommendations
        if any(issue.category == ValidationCategory.TESTS for issue in feedback.issues):
            feedback.recommendations.append(
                "Ensure adequate test coverage for new functionality"
            )
        
        if any(issue.category == ValidationCategory.SECURITY for issue in feedback.issues):
            feedback.recommendations.append(
                "Review security implications and use secure coding practices"
            )

    def _get_stack_specific_recommendations(self, stack: str, issues: List[ValidationIssue]) -> List[str]:
        """Generate stack-specific recommendations."""
        recommendations = []
        
        if stack == 'laravel':
            if any('Controller' in (issue.file_path or '') for issue in issues):
                recommendations.append("Follow Laravel controller conventions and use FormRequests for validation")
            if any(issue.category == ValidationCategory.SECURITY for issue in issues):
                recommendations.append("Use Laravel's built-in security features like CSRF protection and validation")
        
        elif stack == 'react':
            if any('.jsx' in (issue.file_path or '') or '.tsx' in (issue.file_path or '') for issue in issues):
                recommendations.append("Follow React best practices: use hooks, proper state management")
            if any('console.log' in issue.message for issue in issues):
                recommendations.append("Remove debug statements and use proper error handling")
        
        elif stack == 'python':
            if any(issue.category == ValidationCategory.CONVENTIONS for issue in issues):
                recommendations.append("Follow PEP 8 style guidelines and use type hints")
            if any('import' in issue.message for issue in issues):
                recommendations.append("Organize imports: standard library, third-party, local imports")
        
        return recommendations --status