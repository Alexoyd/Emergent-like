import json
import logging
from typing import List, Dict, Any, Union

logger = logging.getLogger(__name__)

def parse_plan(plan: str) -> List[Dict[str, Any]]:
    """
    Parse a plan generated by the LLM.
    
    Args:
        plan (str): The plan string returned by the LLM
        
    Returns:
        List[Dict[str, Any]]: A list of steps, where each step is a dictionary
        
    The function tries to:
    1. Parse the plan as JSON (json.loads)
    2. If it's a list of steps (dicts with action, target, content, description), return as-is
    3. If it's a single dict, wrap it in a list
    4. On parsing failure, return a fallback step that logs the original plan
    """
    
    if not plan or not plan.strip():
        logger.warning("Empty plan provided to parse_plan")
        return [{"action": "log", "content": "Empty plan provided"}]
    
    # First try to parse as JSON
    try:
        parsed = json.loads(plan)
        logger.info("Successfully parsed plan as JSON")
        
        # If it's already a list, validate and return
        if isinstance(parsed, list):
            # Validate that it's a list of dictionaries
            if all(isinstance(item, dict) for item in parsed):
                logger.info(f"Plan contains {len(parsed)} steps")
                return parsed
            else:
                logger.warning("Plan list contains non-dictionary items, falling back")
                return [{"action": "log", "content": plan}]
        
        # If it's a single dictionary, wrap in list
        elif isinstance(parsed, dict):
            logger.info("Plan is a single step, wrapping in list")
            return [parsed]
        
        # If it's neither list nor dict, fall back
        else:
            logger.warning(f"Parsed plan is neither list nor dict (type: {type(parsed)}), falling back")
            return [{"action": "log", "content": plan}]
            
    except json.JSONDecodeError as e:
        logger.warning(f"Failed to parse plan as JSON: {e}")
        
        # Try to extract structured information from text
        try:
            steps = extract_steps_from_text(plan)
            if steps:
                logger.info(f"Extracted {len(steps)} steps from text plan")
                return steps
        except Exception as text_parse_error:
            logger.warning(f"Failed to extract steps from text: {text_parse_error}")
        
        # Final fallback
        logger.info("Using fallback: wrapping entire plan in a single log step")
        return [{"action": "log", "content": plan}]
    
    except Exception as e:
        logger.error(f"Unexpected error parsing plan: {e}")
        return [{"action": "log", "content": f"Error parsing plan: {str(e)}\n\nOriginal plan:\n{plan}"}]


def extract_steps_from_text(plan: str) -> List[Dict[str, Any]]:
    """
    Extract steps from a text-based plan.
    
    This function looks for numbered lists or common patterns in text plans
    and converts them to structured steps.
    """
    steps = []
    lines = plan.strip().split('\n')
    
    current_step = None
    step_counter = 0
    
    for line in lines:
        line = line.strip()
        if not line:
            continue
            
        # Look for numbered steps (1., 2., etc.)
        if (line.startswith(tuple(f"{i}." for i in range(1, 21))) or 
            line.startswith(tuple(f"Step {i}" for i in range(1, 21))) or
            line.startswith(tuple(f"{i}:" for i in range(1, 21)))):
            
            # Save previous step if exists
            if current_step:
                steps.append(current_step)
            
            # Start new step
            step_counter += 1
            current_step = {
                "action": "execute",
                "step_number": step_counter,
                "description": line,
                "content": line
            }
            
        # Look for bullet points or dashes
        elif line.startswith(('-', 'â€¢', '*')):
            if current_step:
                # Add to current step's content
                current_step["content"] += f"\n{line}"
            else:
                # Create a new step for bullet points
                step_counter += 1
                current_step = {
                    "action": "execute",
                    "step_number": step_counter,
                    "description": line,
                    "content": line
                }
                
        # Add other content to current step
        elif current_step:
            current_step["content"] += f"\n{line}"
    
    # Add final step
    if current_step:
        steps.append(current_step)
    
    # If no structured steps found, create one step with the entire plan
    if not steps:
        steps = [{
            "action": "execute",
            "step_number": 1,
            "description": "Execute plan",
            "content": plan
        }]
    
    return steps


def validate_step(step: Dict[str, Any]) -> bool:
    """
    Validate that a step has the required structure.
    
    A valid step should have at least one of: action, description, content
    """
    if not isinstance(step, dict):
        return False
    
    required_keys = ['action', 'description', 'content']
    return any(key in step for key in required_keys)


def normalize_steps(steps: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    """
    Normalize steps to ensure they have consistent structure.
    """
    normalized = []
    
    for i, step in enumerate(steps):
        if not validate_step(step):
            logger.warning(f"Invalid step at index {i}, skipping: {step}")
            continue
            
        normalized_step = {
            "action": step.get("action", "execute"),
            "step_number": step.get("step_number", i + 1),
            "description": step.get("description", f"Step {i + 1}"),
            "content": step.get("content", step.get("description", "")),
            "target": step.get("target", ""),
            "expected_outcome": step.get("expected_outcome", "")
        }
        
        normalized.append(normalized_step)
    
    return normalized